name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  release:
    types:
      - published
  workflow_dispatch:
    inputs:
      test-release:
        description: "Simulate a release"
        required: false
        default: "true"

env:
  RUSTC_VERSION: 1.88.0

jobs:
  docs:
    name: Build & Test Docusaurus Docs
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: docs/package-lock.json

      - name: Install Dependencies
        working-directory: docs
        run: npm ci

      - name: Build Docs
        working-directory: docs
        run: npm run build

      - name: Lint Docs
        working-directory: docs
        run: npm run lint

      - name: Run Tests
        working-directory: docs
        run: npm test

  cargo:
    name: SystemG CI
    runs-on: ubuntu-latest
    needs: [docs]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo Dependencies
        uses: Swatinem/rust-cache@v2

      - name: Install Cargo Tools
        run: |
          cargo install cargo-sort
          rustup component add rustfmt clippy

      - name: Check Cargo.toml Formatting (cargo-sort)
        run: cargo sort --check --workspace

      - name: Run Clippy (Linting)
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Run Rustfmt (Code Formatting)
        run: cargo fmt -- --check

      - name: Run Tests
        run: cargo test --verbose --features linux

  upload-release-binaries:
    name: Upload Release Binaries
    runs-on: ${{ matrix.job.os }}
    needs: [cargo]
    if: github.event_name == 'release' && github.event.action == 'published' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        job:
          - os: ubuntu-latest
            platform: linux
            target: x86_64-unknown-linux-gnu
            cross_image: x86_64-linux-gnu
            features: linux
          - os: ubuntu-latest
            platform: linux-arm
            target: aarch64-unknown-linux-gnu
            cross_image: aarch64-linux-gnu
            features: linux
#          - os: macos-latest
#            platform: darwin
#            target: x86_64-apple-darwin
#            features: macos
#          - os: macos-latest
#            platform: darwin-arm
#            target: aarch64-apple-darwin
#            features: macos

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        if: matrix.job.cross_image
        uses: docker/setup-buildx-action@v1

      - name: Setup custom cross env ${{ matrix.job.cross_image }}
        if: matrix.job.cross_image
        uses: docker/build-push-action@v2
        with:
          context: ci
          file: ci/Dockerfile.${{ matrix.job.target }}-clang
          tags: ${{ matrix.job.cross_image }}:latest
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Install packages (macOS)
        if: matrix.job.os == 'macos-latest'
        run: |
          ci/macos-install-packages.sh
      - uses: actions/checkout@v3

      - name: Install toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ env.RUSTC_VERSION }}
          targets: ${{ matrix.job.target }}

      - name: Install cross
        uses: baptiste0928/cargo-install@v1
        with:
          crate: cross
          cache-key: ${{ matrix.job.target }}

      - name: Build sysg
        run: |
          cross \
            build \
            --profile=release \
            --target ${{ matrix.job.target }} \
            --features ${{ matrix.job.features }}

      - name: Strip release binary linux x86_64
        if: matrix.job.platform == 'linux'
        run: >
          strip "target/${{ matrix.job.target }}/release/sysg"

      - name: Strip release binary aarch64-linux-gnu
        if: matrix.job.target == 'aarch64-unknown-linux-gnu'
        run: |
          docker run --rm -v \
          "$PWD/target:/target:Z" \
          aarch64-linux-gnu:latest \
          aarch64-linux-gnu-strip \
          /target/aarch64-unknown-linux-gnu/release/sysg

      - name: Strip release binary mac
        if: matrix.job.os == 'macos-latest'
        run: >
          strip -x "target/${{ matrix.job.target }}/release/sysg"

      - name: Prepare Binary Artifact
        env:
          PLATFORM_NAME: ${{ matrix.job.platform }}
          TARGET: ${{ matrix.job.target }}
        run: >
          # trim refs/tags/ prefix
          SYSG_VERSION="${GITHUB_REF#refs/tags/}"

          # optionally trim v from tag prefix
          SYSG_VERSION="${SYSG_VERSION#v}"
          echo "version is: SYSG_VERSION"

          # setup artifact filename
          SYSG_ARTIFACT="fuel-indexer-SYSG_VERSION-${{ env.TARGET }}"
          SYSG_ZIP_FILE_NAME="$SYSG_ARTIFACT.tar.gz"
          echo "SYSG_ZIP_FILE_NAME=$SYSG_ZIP_FILE_NAME" >> $GITHUB_ENV

          # create zip file
          mkdir -pv "$SYSG_ZIP_FILE_NAME"
          cp "target/${{ matrix.job.target }}/release/sysg" "$SYSG_ZIP_FILE_NAME"
          tar -czvf "$SYSG_ZIP_FILE_NAME" "$SYSG_ARTIFACT"

      - name: Upload Sysg Artifact
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ github.token }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ./${{ env.SYSG_ZIP_FILE_NAME }}
          asset_name: ${{ env.SYSG_ZIP_FILE_NAME }}
          asset_content_type: application/gzip

#      - name: Notify if Job Fails
#        uses: ravsamhq/notify-slack-action@v2
#        if: always() && (github.ref == 'refs/heads/master' || github.ref_type == 'tag')
#          && matrix.job.os != 'macos-latest'
#        with:
#          status: ${{ job.status }}
#          token: ${{ secrets.GITHUB_TOKEN }}
#          notification_title: "{workflow} has {status_message}"
#          message_format: "{emoji} *{workflow}* {status_message} in <{repo_url}|{repo}> :
#            <{run_url}|View Run Results>"
#          footer: ""
#          notify_when: failure
#        env:
#          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_NOTIFY_BUILD }}

  cargo-publish:
    name: Publish to crates.io
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'published' || github.event_name == 'workflow_dispatch'
    needs: [upload-release-binaries]
    environment: ci
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Publish Crate
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATESIO_TOKEN }}
        run: |
          if [ "${{ github.event.inputs.test-release }}" == "true" ]; then
            cargo publish --dry-run --locked --no-verify
          else
            cargo publish --locked --no-verify
          fi

  upload-r2:
    name: Upload to Cloudflare R2
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'published' || github.event_name == 'workflow_dispatch'
    needs: [cargo-publish]
    environment: ci
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install s3cmd
        run: sudo apt-get update && sudo apt-get install -y s3cmd

      - name: Configure s3cmd for R2
        run: |
          cat > ~/.s3cfg <<EOF
          [default]
          access_key = ${{ secrets.R2_ACCESS_KEY_ID }}
          secret_key = ${{ secrets.R2_SECRET_ACCESS_KEY }}
          host_base = ${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          host_bucket = ${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          use_https = True
          EOF

      - name: Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Upload to Cloudflare R2
        run: |
          find artifacts -name "*.tar.gz" -type f | while read file; do
            s3cmd put "$file" s3://${{ secrets.R2_BUCKET_NAME }}/$(basename "$file") --acl-public
          done
